{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/posts/03-scope/",
    "result": {"data":{"markdownRemark":{"html":"<p>모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 <code class=\"language-text\">스코프</code>라고 한다.</p>\n<p>즉, 스코프는 식별자가 유효한 범위를 말한다.</p>\n<ul>\n<li>함수 내부에서 선언된 변수는 해당 함수 외부에서는 참조할 수 없다.</li>\n<li>스코프를 통해 변수 이름의 충돌을 방지할 수 있다.</li>\n<li>스코프라는 개념이 존재하지 않는다면 코드 내부에 변수 이름은 오직 유일해야 한다.</li>\n<li>우리가 컴퓨터에 파일을 저장할 때, 같은 범위(scope)에서는 같은 이름으로 파일을 저장할 순 없지만 다른 범위(다른 폴더)나 해당 범위 내의 폴더 내(자식 폴더)에는 같은 이름으로 파일을 저장할 수 있는 개념과 비슷하다.</li>\n</ul>\n<br>\n<h2>var과 let, const</h2>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 중복 선언을 허용한다..</span>\n  <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//2</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// SyntaxError: Identifier 'x' has already been declared</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">var</code> 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. 이는 의도치 않게 변수 값이 재할당되어 변경되는 부작용을 발생시킨다.</li>\n<li><code class=\"language-text\">let</code> 이나 <code class=\"language-text\">const</code>로 선언된 변수는 같은 스코프 내에서 중복 선언이 불가하다!</li>\n</ul>\n<br>\n<p>대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블록이 지역 스코프를 만든다. 이러한 특성을 <code class=\"language-text\">블록 레벨 스코프(block level scope)</code> 라 한다. <strong>하지만 var로 선언된 변수는 오로지 함수 코드 블록만을 지역 스코프로 인정한다.</strong></p>\n<p>하지만 <strong>let, const 키워드는 블록 레벨 스코프를 지원한다</strong></p>\n<br>\n<h3>변수 호이스팅</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError</span>\n<span class=\"token keyword\">let</span> x<span class=\"token punctuation\">;</span></code></pre></div>\n<p>var 키워드와 다르게 let 키워드로 선언한 변수는 호이스팅이 발생하지 않는 것 처럼 동작한다.</p>\n<br>\n<p>사실은 var 키워드로 선언한 변수는 런타임 이전에 <code class=\"language-text\">선언 단계</code>와 <code class=\"language-text\">초기화 단계</code>를 한번에 진행한다.</p>\n<p>즉, var 키워드로 선언한 변수는 변수의 존재를 알리는 것과 동시에 <code class=\"language-text\">undefined</code>로 초기화 한다.</p>\n<p>그러나 <code class=\"language-text\">let</code> 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 선언 단계는 런타임 이전에 실행되지만, <strong>초기화 단계는 변수 선언문에 도달했을 때 실행된다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 전역 변수</span>\n\n<span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 지역 변수 x 선언문에 도달하지 않았으므로 초기화 단계가 실행되지 않았다.</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError: Cannot access 'x' before initialization</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let 키워드로 선언한 변수는 블록 레벨 스코프이므로 지역변수</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3>const 키워드</h3>\n<p><strong>const 키워드로 선언한 변수는 선언과 동시에 초기화를 해야한다.</strong></p>\n<p>const도 let과 마찬가지로 블록 레벨 스코프를 가지며, 선언 단계와 초기화 단계가 분리되어 진행된다.</p>\n<ul>\n<li><code class=\"language-text\">const x = 1</code> 에 도달해야 초기화 단계를 거치게 된다.</li>\n</ul>\n<p><br>const 키워드로 선언한 변수는 재할당이 금지된다. 여기서 주의해야 할 점이 있다.</p>\n<p>const 키워드로 선언한 변수의 값이 <code class=\"language-text\">원시 타입 (객체 타입이 아닌)</code>인 경우 값을 변경하려면 <code class=\"language-text\">재할당</code>을 해야한다. 하지만 <strong>객체 타입의 경우 주소 값을 저장하고 있으므로 객체 내의 값을 변경하고자 할때는 재할당이 이루어지지 않는다.</strong> 따라서 객체를 할당한 경우 값을 변경할 수 있다.</p>\n<p><strong>const 키워드는 재할당을 금지할 뿐, 불변을 의미하지 않는다.</strong></p>\n<br>\n<h2>스코프의 종류</h2>\n<blockquote class=\"brown-border bg-soft\">\n<p>전역 스코프</p>\n<p>지역 스코프</p>\n</blockquote>\n<table class=\"bg-soft\">\n<thead>\n<tr>\n<th>구분</th>\n<th>설명</th>\n<th>스코프</th>\n<th>변수</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>전역</td>\n<td>코드의 바깥 영역</td>\n<td>전역 스코프</td>\n<td>전역 변수</td>\n</tr>\n<tr>\n<td>지역</td>\n<td>함수의 내부</td>\n<td>지역 스코프</td>\n<td>지역 변수</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>전역 변수는 어디서든지 참조할 수 있다.</li>\n<li>지역 변수는 자신의 영역 혹은 하위 지역 스코프에서 유효하다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; margin: 2rem 0\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMCBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAbdN9lgf/8QAGhAAAgMBAQAAAAAAAAAAAAAAAgMBBBARI//aAAgBAQABBQJ8+tWe4VdRkCgXn//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABwQAAICAgMAAAAAAAAAAAAAAAECESIAEBJxgf/aAAgBAQAGPwJrsPcaxPeuTJJyixOv/8QAGhAAAgMBAQAAAAAAAAAAAAAAAREAEDFxQf/aAAgBAQABPyFIuQFOC9OjAAmmO1eyr//aAAwDAQACAAMAAAAQs8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAwADAQAAAAAAAAAAAAABIQARMRBBUXH/2gAIAQEAAT8QKopC4BDoQ4WqnTTfYLpzbXYS+vZW0BhdZv3j/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"scope\"\n        title=\"scope\"\n        src=\"/static/7971ece8df97e76c643f0724f895a737/4b190/scope.jpg\"\n        srcset=\"/static/7971ece8df97e76c643f0724f895a737/e07e9/scope.jpg 200w,\n/static/7971ece8df97e76c643f0724f895a737/066f9/scope.jpg 400w,\n/static/7971ece8df97e76c643f0724f895a737/4b190/scope.jpg 800w,\n/static/7971ece8df97e76c643f0724f895a737/e5166/scope.jpg 1200w,\n/static/7971ece8df97e76c643f0724f895a737/eea4a/scope.jpg 1280w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<h2>스코프 체인</h2>\n<p>모든 스코프는 하나의 계층적 구조로 연결되며, 이렇게 스코프가 계층적으로 연결된 것을 <code class=\"language-text\">스코프 체인(scope chain)</code> 이라고 한다.</p>\n<p>변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 해당 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. (identifier resolution)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; margin: 2rem 0\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAgAF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3wyOo//EABcQAAMBAAAAAAAAAAAAAAAAAAABEBH/2gAIAQEAAQUCFUsn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRAAAwADAAAAAAAAAAAAAAAAARARACFB/9oACAEBAAE/Ic70x1Av/9oADAMBAAIAAwAAABDgD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQACAwEAAAAAAAAAAAAAAAEAERAhMXH/2gAIAQEAAT8QeMatke4SxI0qr7vH/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"scopechain\"\n        title=\"scopechain\"\n        src=\"/static/e4a3219b1fecaada47efd52357bc5ccb/4b190/scopechain.jpg\"\n        srcset=\"/static/e4a3219b1fecaada47efd52357bc5ccb/e07e9/scopechain.jpg 200w,\n/static/e4a3219b1fecaada47efd52357bc5ccb/066f9/scopechain.jpg 400w,\n/static/e4a3219b1fecaada47efd52357bc5ccb/4b190/scopechain.jpg 800w,\n/static/e4a3219b1fecaada47efd52357bc5ccb/e5166/scopechain.jpg 1200w,\n/static/e4a3219b1fecaada47efd52357bc5ccb/eea4a/scopechain.jpg 1280w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<p>스코프 체인은 물리적으로 존재한다. 자바스크립트 엔진은 코드를 실행하기 전에 <code class=\"language-text\">렉시컬 환경(Lexical Environment)</code>을 생성한다.</p>\n<br>\n<h2>렉시컬 스코프</h2>\n<ul>\n<li>동적 스코프(dynamic scope) : <strong>함수를 호출하는 시점</strong>에 동적으로 상위 스코프를 결정한다.</li>\n<li><code class=\"language-text\">렉시컬 스코프(Lexical scope)</code> : <strong>함수를 정의하는 시점</strong>에 따라 상위 스코프를 결정한다. 즉, ㅈ함수의 상위 스코프는 언제나 자신이 정의된 스코프이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 : foo에서 bar를 실행했지만 bar의 상위 스코프는 전역 스코프</span>\n<span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 : 전역 스코프의 x</span></code></pre></div>","frontmatter":{"date":"April 28, 2021","slug":"/posts/03-scope","title":"[JavaScript] 스코프와 var, let 그리고 const","description":"(모던 자바스크립트 deep dive) JavaScript의 스코프와 var, let, const에 대해 알아보자"}}},"pageContext":{"id":"4f475cf4-621e-5980-b1e7-0099492780b9","frontmatter__slug":"/posts/03-scope","__params":{"frontmatter__slug":"posts"}}},
    "staticQueryHashes": []}